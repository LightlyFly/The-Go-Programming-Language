# 使用共享变量实现并发

如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是并发的。考虑一个能在串行程序中正确工作的函数。如果这个函数在并发调用时仍然能正确工作，那么这个函数是并发安全的。

导出的包级别函数通常可以认为是并发安全的。因为包级别的变量无法限制在一个 `goroutine` 内，所以那些修改这些变量的函数就必须采用互斥机制。

竞态是指在多个 `goroutine` 按某些交错顺序执行时程序无法给出正确的结果。数据竞态发生于两个 `goroutine` 并发读写同一个变量并且至少其中一个是写入时。

由于其他 `goroutine` 无法直接访问相关变量，因此它们就必须使用通道来向受限 `goroutine` 发送查询请求或者更新变量。这也是这句 Go 箴言的含义：“不要通过共享内存来通信，而应该通过通信来共享内存”。

## 互斥锁

`sync.Mutex`

互斥锁是不能再入的（无法对一个已经上锁的互斥量再上锁），这样做将会导致死锁。

读写互斥锁：`sync.RWMutex`

读写互斥锁允许只读操作可以并发执行，但写操作需要获得完全独享的访问权限。仅在绝大部分 `goroutine` 都在获取读锁并且锁竞争比较激烈时（即：`goroutine` 一般都需要等待后才能获到锁），`RWMutex` 才有优势。因为 `RWMutex` 需要更复杂的内部工作，所以在竞争不激烈时它比普通的互斥锁慢。

## 内存同步

现代的计算机一般都会有多个处理器，每个处理器多有内存的本地缓存。为了提高效率，对内存的写入是缓存在每个处理器中的，只有在必要时才刷回内存。甚至刷回内存的顺序都可能与 `goroutine` 的写入顺序不一致。像通道通信或者互斥锁操作这样的同步原语都会导致处理器把累积的写操作刷回内存并提交，所以这个时刻之前 `goroutine` 的执行结果就保证了对运行在其他处理器的 `goroutine` 可见。

考虑如下代码片段的可能输出：

```go
var x, y int
go func() {
    x = 1
    fmt.Print("y:", y, " ")
}()
go func() {
    y = 1
    fmt.Print("x:", x, " ")
}
```

程序将会产生如下两个输出

```go
x:0 y:0
y:0 x:0
```

在某些特定的编译器、CPU 或其他情况下，这些确实可能发生。在单个 `goroutine` 内，每个语句的效果保证按照执行的顺序发生，也就是说，`goroutine` 是串行一致的。但在缺乏使用通道或者互斥量来显式同步的情况下，并不能保证所有的 `goroutine` 看到的事件顺序都是一致的。如果两个 `goroutine` 在不同的 CPU 上执行，每个 CPU 都有自己的缓存，那么一个 `goroutine` 的写入操作再同步到内存之前对另外一个 `goroutine` 的 `Print` 语句是不可见的。

## 延迟初始化：sync.Once

`sync.Once` 包含一个布尔变量和一个互斥量，布尔变量记录初始化是否已经完成，互斥量则保护这个布尔变量和客户端的数据结构。`Once` 的唯一方法 `Do` 以初始化函数作为它的参数。

```go
var loadIconsOnce sync.Once
var icons map[string]image.Image

// 并发安全
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
```

每次调用 `Do（loadIcons)` 时会先锁定互斥量并检查里面的布尔变量。在第一次调用时，这个布尔变量为假，`Do` 会调用 `loadIcons` 然后把变量设置为真。后续的调用相当于空操作，只是通过互斥量的同步来保证 `loadIcons` 对内存产生的效果对所有的 `goroutine` 可见。以这种方式来使用 `sync.Once`，可以避免变量在正确狗仔之前就被其他 `goroutine` 分享。

## goroutine 与线程

每个 OS 线程都有一个固定大小的栈内存(通常为 2MB)，栈内存区域用于保存在其他函数调用期间那些正在执行或临时暂停的函数中的局部变量。

作为对比，一个 `goroutine` 在生命周期开始时只有一个很小的栈，典型情况下为 2KB。与 OS 线程类似，`goroutine` 的栈也用于存放那些正在执行或临时暂停的函数中的局部变量。但与 OS 线程不同的是，`goroutine` 的栈不是固定大小的，它可以按需增大或缩小。`goroutine` 的栈大小限制可以达到 1GB。

OS 线程由 OS 内核来调度。每隔几毫秒，一个硬件时钟中断发到 CPU，CPU 调用一个叫调度器的内核函数。这个函数暂停当前正在执行的线程，把它的寄存器信息保存到内存，查看线程列表并决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程。因为 OS 线程由内核来调度，所以控制权限从一个线程到另一个线程需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。考虑这个操作设计的内存局域性以及设计的内存访问数量，还有访问内存所需的 CPU 周期数量的增加，这个操作其实是很慢的。

Go 运行时包含一个自己的调度器，这个调度器使用一个称为 `m:n` 调度的技术（因为它可以复用/调度 m 个 `goroutine` 到 n 个 OS 线程）。Go 调度器与内核调度器的工作类似，但 Go 调度器只需关心单个 Go 程序的 `goroutine` 调度问题。

与操作系统的线程调度器不同的是，Go 调度器不是由硬件时钟来定期触发的，而是由特定的 Go 语言结构来触发的。比如当一个 `goroutine` 调用 `time.Sleep` 或被通道阻塞或对互斥量操作时，调度器就会将这个 `goroutine` 设为休眠模式，并运行其他 `goroutine` 直到前一个可重新唤醒为止。因为它不需要切换到内核语境，所以调用一个 `goroutine` 比调度一个线程成本低很多。

Go 调度器使用 GOMAXPROCS 参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 数量，所以在一个有 8 个 CPU 的机器上，调度器会把 Go 代码同时调度到 8 个 OS 线程上。