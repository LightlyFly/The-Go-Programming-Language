# 基本数据

## 整数

- Go 同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64位，用 int8、int16、int32、int64 表示，对应的无符号整数是 uint8、uint16、uint32、uint64；
- 此外还有两种类型 int 和 uint。在特定平台上，其大小与原生的有符号整数/无符号整数相同，或等于该平台上的运算效率最高的值。int 是目前使用最广泛的整数类型。这两种类型大小相等，都是 32 位或 64 位；
- rune 类型是 int32 类型的同义词，常常用于指明一个值是 Unicode 码点。byte 类型是 unit8 类型的同义词，强调一个值是原始数据。
- 还有一种无符号整数 uintptr，其大小并不明确，但足以完整存放指针；
- 除法运算（/）的行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分，于是 5.0/4.0 得到 1.25，而 5/4 结果是 1；
- 无论是有符号数还是无符号数，若表示算数运算结果所需的位是超出该类型的范围，就称为溢出。溢出的高位部分会无提示地丢弃；

```go
var u unit8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"

var i int8 = 127
fmt.Println(i, i + 1, i * i) // "127 -128 1"
```

- 全部基本类型的值（布尔值、数值、字符串）都可以比较，这意味着两个相同类型的值可用 == 或 != 运算符比较；

- 类型不匹配（+ 的问题）有几种方法改正，最直接地，将全部操作数转换为同一类型：
- var compote = int(apples) + int(oranges)
- 对于每种类型 T，若允许转换，操作 T(x) 会将 x 的值转换为 T。很多整型 - 整型转换不会引起值的变化，仅告知编译器应如何解读该值。不过浮点数转为整型，会舍弃小数部分，趋零截尾（正值向下取整，负值向上取整）；

- 无论有无大小和符号限制，源码中的整数都能写成常见的十进制数；也能写成八进制数，以 0 开头，如 0666；还能写成十六进制数，以 0x 或 0X 开头，如 0xdeadbeef；

```go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
// 输出：
// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```

- 注意 fmt 的两个技巧。它通常 Printf 的格式化字符串包含有多个 % 谓词，这要求提供相同数目的操作数，而 % 后的副词 [1] 告知 Printf 重复使用第一个操作数。其次，%o、%x 或 %X 之前的副词 # 告知 Printf 输出对应的前缀 0、0x、0X；
- 源码中，文字符号（rune literal）的形式是字符写在一对单引号内。最简单的例子就是 ASCII 字符，如 'a'，但也可以直接使用 Unicode 码点。

## 浮点数

- Go 具有两种大小的浮点数 float32 和 float64；
- 十进制下，float32 的有效数字大约是 6 位，float64 的有效数字大约是 15 位；绝大多数情况下，应优先选用 float64；
- 浮点值能方便地通过 Printf 的谓词 %g 输出，该谓词会自动保持足够的精度；
- math.IsNaN 函数判断其参数是否是非数值，math.NaN 函数则返回非数值（NaN）

## 布尔值

- bool 型的值或布尔值（boolean）只有两种可能：真（true）和假（false）。if 和 for 语句里的条件就是布尔值，比较操作符（如 == 和 <）也能得出布尔值结果。

## 字符串

- 字符串是不可变的字节序列，它可以包含任意数据，包括 0 值字节，但主要是人类可读的文本。习惯上，文本字符串被解读成按 UTF-8 编码的 Unicode 码点（文字符号）序列。
- 字符串 s 及其子串（如 s[7:]）可以安全地公用数据，因此子串生成操作的开销低廉；
- 原生的字符串字面量的书写形式是 `...`；

- Unicode
- 从前，事情简单明晰，至少，狭隘的来看，软件只需要处理一个字符集：ASCII（美国信息交换标准码）。ASCII（或更确切地说，US-ASCII）码使用 7 位表示 128 个“字符”：大小写英文字母、数字、各种标点和设备控制符；
- Unicode 囊括了世界上所有文书体系的全部字符，还有重音符和其他变音符，控制码（如制表符和回车符），以及许多特有文字，对它们各自赋予了一个 Unicode 码点的标准数字。
- Unicode 第 8 版定义了超过一百种语言文字的 12 万个字符的码点。它们在计算机程序中的数据类型是 int32，Go 采用的就是该类型，正因如此，rune 类型作为 int32 类型的别名；
- 我们可以将文字符号的序列表示成 int32 序列，这种表示方式称作 UTF-32 或 UCS-4，每个 Unicode 码点的编码长度相同，都是 32 位。这种编码方式简单划一，可是因为大多数面向计算机的刻度文本是 ASCII 码，每个字符只需 8 位，也就是 1 字节，导致了不必要的存储空间消耗。而使用广泛的字符的数目也少于 65556 个，字符用 16 位就能容纳，因此该方法可以进一步优化。

- UTF-8
- UTF-8 以字节为单位对 Unicode 码点作变长编码。UTF-8 是线性的一种 Unicode 标准，由 Go 的两位创建者发明。每个文字符号用 1~4 个字节表示，ASCII 字符的编码仅占 1 个字节，而其他常用的文书字符的编码只是 2 或 3 个字符。一个字符号编码的首字节的高位指明了后面还有多少字节。若最高位为 0，则标示着它是 7 位的 ASCII 码，其文字符号的编码仅占 1 字节，这样就与传统的 ASCII 码一致。若最高几位是 110，则文字符号的编码占用 2 个字节，第二个字节以 10 开始。更长的编码以此类推。

```
0xxxxxxx 文字符号 0 ~ 127 (ASCII)
110xxxxx 10xxxxxx 128 ~ 2047 少于 128 个未使用的值
1110xxxx 10xxxxxx 10xxxxxx 2048 ~ 65535 少于 2048 个未使用的值
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536 ~ 0x10ffff 其他未使用的值
```

- Go 的源文件总是以 UTF-8 编码。
- 如果我们真的要逐个逐个处理 Unicode 字符，则必须使用其他编码机制。下面的例子说明了该字符串的内存布局。它含有 13 个字节，而按作 UTF-8 解读，本质是 9 个码点或文字符号的编码：

```go
import "unicode/utf8"

s := "Hello, 世界"
fmt.Println(len(s)) // 13
fmt.Println(utf8.RuneCountInString(s)) // 9
```

- Go 的 range 循环也适用于字符串，内部按照 UTF-8 隐式解码；
- 若将一个整数值转换为字符串，其值按文字符号类型解读，并且产生代表该文字符号值的 UTF-8 码：

```go
fmt.Println(string(65)) // "A"，而不是 "65"
fmt.Println(string(0x4eac)) // "京"
```

## 字符串和字节 slice

- 4 个标准包对字符串操作特别重要：bytes、strings、strconv 和 unicode。
- strings 包提供了许多函数，用于搜索、替换、比较、修整、切片与连接字符串；
- bytes 包也有类似的函数，用于操作字节 slice（[]byte 类型，其某些属性和字符串相同）；
- strconv 包具备的函数，主要用于转换布尔值、整数、浮点数为与之对应的字符串形式，或者把字符串转换为布尔值、整数、浮点数，另外还有为字符串添加/去除引号的函数。
- unicode 包备有判别文字符号值特性的函数，如 IsDigit、IsLetter、IsUpper 和 IsLower。每个函数以单个文字符号值作为参数，并返回布尔值。
- 字符串可以和字节 slice 相互转换：

```go
s := "abc"
b := []byte(s)
s2 := string(b)
```

- 字符串和数字的相互转换

```go
// 要将整数转换成字符串，一种选择是使用 fmt.Sprintf，另一种做法是用函数 strconv.Itoa ("integer to ASCII")
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x))

// FormatInt 和 FormatUnit 可以按不同的进位制格式化数字：
fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"

// fmt.Printf 里的谓词 %b、%d、%o 和 %x 往往比 Format 函数方便，若要包含数字以外的附加信息，它就尤其有用：
s ：= fmt.Sprintf("x=%b", x) // "x=1111011"

// strconv 包内的 Atoi 函数或 ParseInt 函数用于解释表示整数的字符串，而 ParseUint 用于无符号整数：
// ParseInt 的第三个参数指定结果必须匹配何种大小的整型；例如，16 表示 int16，0 作为特殊值表示 int。任何情况下，结果 y 的类型总是 int64，可将他另外转换成较小的类型。
x, err := strconv.Atoi("123") // x 是整型
y, err := strconv.ParseInt("123", 10, 64)
```

## 常量

- 常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型、字符串或数字。
- 常量的声明可以使用常量生成器 iota，它创建一系列相关值，而不是逐个值显式写出。常量声明中，iota 从 0 开始取值，逐项加 1。