# 函数

- 函数包含连续的执行语句，可以在代码中通过调用函数来执行它们。

## 函数声明

每个函数都包含一个名字、一个形参列表、一个可选的返回列表以及函数体：

```go
func name(parameter-list) (result-list) {
  body
}
```

- 函数的类型称作函数签名。当两个函数拥有相同的形参列表和返回列表时，认为这两个函数的类型或签名是相同的。
- 每一次调用函数都需要提供实参来对应函数的每一个形参，包括参数的调用顺序也必须一致。Go 语言没有默认参数值的概念也不能指定实参名。
- 形参变量都是函数的局部变量，初始值由调用者提供的实参传递。函数形参以及命名返回值同属于函数最外层作用域的局部变量。
- 实参是按值传递的，所以函数接收到的是每个实参的副本；修改函数的形参变量并不会影响到调用者提供的实参。然而，如果提供的实参包含引用类型，比如指针、slice、map、函数或者通道，那么当函数使用形参变量时就有可能会间接地修改实参变量。
- 你可能偶尔会看到有些函数的声明没有函数体，那说明这个函数使用除了 Go 以外的语言实现。这样的声明定义了该函数的签名。

```go
package math 

func Sin(x float64) float64 // 使用汇编语言实现
```

## 递归

- 函数可以递归调用，这意味着函数可以直接或间接地调用自己。
- 许多编程语言使用固定长度的函数调用栈；大小在 64KB 到 2MB 之间。递归的深度受限于固定长度的栈大小，相比较固定长的栈，Go 语言的实现使用了可变长度的栈，栈的大小会随着使用而增长，可达到 1GB 左右的上限。这使得我们可以安全地使用递归而不用担心溢出问题。

## 多返回值

- 一个函数能够返回不止一个结果。
- 我们必须保证 resp.Body 正确关闭使得网络资源正常释放。即使在发送错误的情况下也必须释放资源。Go 语言的垃圾回收机制将回收未使用的内存，但不能指望它会释放未使用的操作系统资源，比如打开的文件以及网络连接。必须显式地关闭它们。
- 良好的名称可以使得返回值更加有意义。尤其在一个函数返回多个结果且类型相同时，名字的选择更加重要，比如：

```go
func Size(rect image.Rectangle) (width, height int)
func Split(path string) (dir, file string)
func HourMinSec(t time.Time) (hour, minute, second int)
```

- 一个函数如果有命名的返回值，可以省略 return 语句的操作数，这称为裸返回。
- 裸返回可以消除重复代码，但是并不能使代码更加易于理解，鉴于这个原因，应保守使用裸返回。

## 错误

- 对于许多函数而言，即使在高质量的代码中，也不能保证一定能够成功返回，因为有些因素并不受程序设计者的掌控。比如任何操作 I/O 的函数都一定会面对可能的错误，只有没有经验的程序员会认为一个简单的读或写不会失败。事实上，这些地方是我们最需要关注的，很多可靠的操作都可能会毫无征兆地发生错误。
- 一般当一个函数返回一个非空错误时，它其他的结果都是未定义的而且应该忽略。
- 与许多其他语言不同，Go 语言通过使用普通的值而非异常来报告错误。尽管 Go 语言有异常机制，但是 Go 语言的异常只是针对程序 bug 导致的预料外的错误，而不能作为常规的错误处理方法出现在程序中。

- 错误处理策略
- 首先也最常见的情形是将错误传递下去，使得子例程中发生的错误变为主调例程的错误。

```go
resp, err := http.Get(url)
if err != nil {
  return nil, err
}
```

- 对比之下，如果调用 html.Parse 失败，findLinks 将不会直接返回 HTML 解析的错误，因为它缺失两个关键信息：解析器的出错信息与被解析文档的 URL。在这种情况下，findLinks 构建一个新的错误信息，其中包含我们需要的所有相关信息和解析的错误信息：

```go
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
  return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}
```

- 我们为原始的错误信息不断地添加额外的上下文信息来建立一个可读的错误描述。当错误最终被程序的 main 函数处理时，它应当能够提供一个从最根本问题到总体故障的清晰因果链；
- 因为错误信息频繁地串联起来，所以消息字符串首字母不应该大写而且应该避免换行。错误结果可能会很长，但能够使用 grep 这样的工具找到我们需要的信息。
- Go 语言的错误处理有特定的规律。进行错误检查之后，检测到失败的情况往往都在成功之前。如果检测到失败导致函数返回，成功的逻辑一般不会放在 else 块中而是在外层的作用域中。函数会有一种通常的形式，就是在开头有一连串的检查用来返回错误，之后跟着实际的函数体一直到最后。

## 函数变量

- 函数在 Go 语言中是一等公民：就像其他值，函数变量也有类型，而且它们可以赋给变量或者传递或者从其他函数中返回。
- 函数类型的零值是 nil（空值），调用一个空的函数变量将导致宕机。

## 匿名函数

- 命名函数只能在包级别的作用域进行声明，但我们能够使用函数字面量在任何表达式内指定函数变量。
- 函数变量类似于使用闭包方法实现的变量，Go 程序员通常把函数变量称为闭包。

## 变长函数

- 变长函数被调用的时候可以有可变的参数个数；
- 在参数列表最后的类型名称之前使用省略号 “...” 表示声明一个变长函数，调用这个函数的时候可以传递该类型任意数目的参数。

## 延迟函数调用

- resp.Body.Close() 的调用，可以保证函数在任何执行路径下都会关闭网络连接，包括发送错误的情况。随着函数变得越来越复杂，并且需要处理更多的错误情况，这样一种重复的清理动作会造成之后的维护问题。