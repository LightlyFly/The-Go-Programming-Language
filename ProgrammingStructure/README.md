# 程序结构

## 名称

- Go 的编程风格倾向于使用短名称；
- 当遇到由单词组合的名称时，Go 程序员使用“驼峰式”的风格 —— 更喜欢使用大写字母而不是下划线。

## 变量

- 零值机制保障所有的变量是良好定义的，Go 里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。
- 因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明；
- 变量是存储值的地方。指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。

```go
x := 1
p := &x // p 是整数指针，指向 x
fmt.Println(*p) // "1"
*p = 2 // 等于 x = 2
fmt.Println(x) // 结果 "2"
```

- 因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够让函数更新间接传递的变量值。
- 另一种创建变量的方式是使用内置的 new 函数。表达式 new（T）创建一个未命名的 T 类型变量，初始化为 T 类型的零值，并返回其地址（地址类型为 *T）；

```go
p := new(int) // *int 类型的 p, 指向未命名的 int 变量
fmt.Println(*p) // 输出 "0"
*p = 2 // 把未命名的 int 设置为 2
fmt.Println(*p) // 输出 2
```

- 变量的生命周期
- 生命周期指在程序执行过程中变量存在的时间段。包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。函数的参数和返回值也是局部变量，它们在其闭包函数被调用的时候创建。
- 变量的生命周期是写出高效程序所必需清楚的。例如，在长生命周期对象中保持短生命周期对象不必要的指针，特别是全局变量中，会阻止垃圾回收器回收短生命周期的对象空间。

## 变量声明

```go
x = 1
*p = true
x, y = y, x
```

- 从风格上考虑，如果表达式比较复杂，则避免使用多重赋值形式；一系列独立的语句会比较易读。
- 通常函数使用额外的返回值来指示一些错误情况，如果 map 查询、类型断言或者通道接收动作出现在两个结果的赋值语句中，都会产生一个额外的布尔型结果：

```go
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
```

- 可赋值性
  - 赋值只有在值对变量类型是可赋值的时才合法；
  - 赋值的规则：类型必须精准匹配，nil 可以被赋给任何借口变量或引用类型；

## 类型声明

type 声明定义一个新的命名类型，它与某个已有类型使用同样的底层类型。

```go
type name underlying-type
```

类型的声明通常出现在包级别，这里命名的类型在整个包中可见，如果名字是导出的（开头使用大写字母），其他的包也可以访问它。

对于每个类型 T，都有一个对应的类型转换操作 T(x) 将值 x 转换为类型 T。如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的。类型转换不改变类型值的表达方式，仅改变类型。

## 包和文件

- 在 Go 语言中包的作用和其他语言中的库或模块作用类似，用于支持模块化、封装、编译隔离和重用。
- 在 Go 里，通过一条简单的规则来管理标识符是否对外可见：导出的标识符以大写字母开头。
- `fmt.Println` 默认会调用类型 T 的 String() 方法进行隐式转换；

## 包初始化

- 包的初始化从初始化包级别的变量开始，这些变量按照声明顺序初始化，在依赖已解析完毕的情况下，根据依赖的顺序进行；
- 任何文件都可以包含任意数量的声明函数（如下）：

```go
func init() { /* ... */ }
```

- 这个 `init` 函数不能被调用和被引用，另一方面，它也是普通的函数。在每一个文件里，当程序启动的时候，`init` 函数按照它们声明的顺序自动执行。